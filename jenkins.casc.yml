jenkins:
  systemMessage: "üöÄ Jenkins with Configuration as Code (JCasC)"
  numExecutors: 2
  mode: NORMAL

  securityRealm:
    local:
      allowsSignup: false
      users:
        - id: "${ADMIN_USER}"
          password: "${ADMIN_PASS}"
  
  authorizationStrategy:
    loggedInUsersCanDoAnything:
      allowAnonymousRead: false

security:
  apiToken:
    creationOfLegacyTokenEnabled: false
    tokenGenerationOnCreationEnabled: true
    usageStatisticsEnabled: true

unclassified:
  location:
    url: "http://localhost:8080/"

# Git is automatically available - no need to configure it as a tool

credentials:
  system:
    domainCredentials:
      - credentials:
          - usernamePassword:
              scope: GLOBAL
              id: "git-credentials"
              username: "${GIT_USERNAME}"
              password: "${GIT_PASSWORD}"
              description: "GitHub credentials (from .env)"
jobs:
  - script: >
      pipelineJob('git-documentation-pipeline') {
        description('Automated CI/CD pipeline for git-documentation with environment-based dynamic parameters')

        parameters {
          activeChoiceParam('ENVIRONMENT') {
            description('Select deployment environment')
            choiceType('SINGLE_SELECT')
            groovyScript {
              script('return ["dev", "qa", "staging", "prod"]')
              fallbackScript('return ["dev"]')
            }
          }

          activeChoiceReactiveParam('SERVER') {
            description('Server auto-populated based on environment')
            choiceType('SINGLE_SELECT')
            groovyScript {
              script("""
                def env = ENVIRONMENT ?: "dev"
                def p = ["sh", "/var/jenkins_home/scripts/get_servers.sh", env].execute()
                p.waitFor()
                def out = p.in.text.trim()
                return out ? out.split("\\n") as List : ["error-no-servers"]
              """)
              fallbackScript('return ["fallback-server"]')
            }
            referencedParameter('ENVIRONMENT')
          }

          activeChoiceReactiveParam('CONTAINER_NAME') {
            description('Container name auto-generated from server')
            choiceType('SINGLE_SELECT')
            groovyScript {
              script("""
                if (SERVER && !SERVER.contains("error") && !SERVER.contains("fallback")) {
                  def p = ["sh", "/var/jenkins_home/scripts/generate_container_name.sh", SERVER].execute()
                  p.waitFor()
                  def out = p.in.text.trim()
                  return out ? [out] : ["error-container"]
                }
                return ["error-no-server"]
              """)
              fallbackScript('return ["fallback-container"]')
            }
            referencedParameter('SERVER')
          }

          stringParam('GIT_BRANCH', 'master', 'Git branch to checkout')
          stringParam('GIT_URL', 'https://github.com/mudunuri010/git-documentation', 'Git repository URL')
          booleanParam('FORCE_REMOVE', true, 'Force remove existing container before deploy?')
        }

        definition {
            cpsScm {
                  scm {
                     git {
                      remote('https://github.com/mudunuri010/git-documentation')
                      branch('*/main')
                      extensions { cleanBeforeCheckout() }
                }
             }
                    scriptPath('Jenkinsfile')
                }
            }

                
                stages {
                  stage('Initialize') {
                    steps {
                      script {
                        echo "=== Build Configuration ==="
                        echo "Build Number:    ${BUILD_NUMBER}"
                        echo "Environment:     ${params.ENVIRONMENT}"
                        echo "Server:          ${params.SERVER}"
                        echo "Container:       ${params.CONTAINER_NAME}"
                        echo "Git Branch:      ${params.GIT_BRANCH}"
                        echo "Image:           ${env.IMAGE_NAME_TAG}"

                        def portCmd = ["sh", "/var/jenkins_home/scripts/get_port.sh", params.ENVIRONMENT]
                        def portProc = portCmd.execute()
                        portProc.waitFor()
                        env.HOST_PORT = portProc.in.text.trim()
                        echo "Port:            ${env.HOST_PORT}"
                        echo "=========================="
                      }
                    }
                  }

                  stage('Checkout') {
                    steps {
                      checkout([
                       
                        branches: [[name: "*/${params.GIT_BRANCH}"]],
                        userRemoteConfigs: [[url: params.GIT_URL, credentialsId: "git-credentials"]],
                        extensions: [[$class: "CleanBeforeCheckout"]]
                      ])
                    }
                  }

                  stage('Build Image') {
                    steps {
                      script {
                        echo "Building: ${env.IMAGE_NAME_TAG}"
                        docker.build(env.IMAGE_NAME_TAG, ".")
                      }
                    }
                  }

                  stage('Cleanup') {
                    when { expression { params.FORCE_REMOVE } }
                    steps {
                      sh "docker stop ${params.CONTAINER_NAME} || true"
                      sh "docker rm ${params.CONTAINER_NAME} || true"
                    }
                  }

                  stage('Deploy') {
                    steps {
                      sh '''
                        docker run -d \
                          --name ${CONTAINER_NAME} \
                          -p ${HOST_PORT}:3000 \
                          ${IMAGE_NAME_TAG}
                      '''
                    }
                  }

                  stage('Verify') {
                    steps {
                      sleep 5
                      sh "docker ps | grep ${params.CONTAINER_NAME}"
                      echo "‚úÖ Live at: http://localhost:${env.HOST_PORT}"
                    }
                  }
                }

                post {
                  success {
                    echo "üéâ Deployment successful!"
                    echo "Access: http://localhost:${env.HOST_PORT}"
                  }
                  failure {
                    echo "‚ùå Deployment failed!"
                  }
                }
              }
            """.stripIndent())
          }
        }
      }
